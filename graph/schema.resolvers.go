package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"fmt"
	"log"
	"strconv"

	"post-system/graph/model"
	"post-system/pkg/models"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, authorID string) (*model.Post, error) {
	// Создаём объект поста
	authorIDUint, _ := strconv.ParseUint(authorID, 10, 64)
	post := &models.Post{
		Title:    title,
		Content:  content,
		AuthorID: uint(authorIDUint), // Убедись, что модель User корректна
	}

	// Пытаемся сохранить в БД
	if err := r.DB.Create(post).Error; err != nil {
		log.Printf("Ошибка при создании поста: %v", err) // Логируем ошибку
		return nil, fmt.Errorf("не удалось создать пост: %w", err)
	}

	resPost := model.Post{ // Создаём просто структуру, без указателя
		ID:            strconv.FormatUint(uint64(post.ID), 10),
		Title:         post.Title,
		Content:       post.Content,
		AllowComments: post.AllowComments,
		CreatedAt:     post.CreatedAt.String(),
	}

	return &resPost, nil // Берём адрес от структуры, создавая *model.Post
}

// CreateParentComment - создание родительского комментария (без parentID)
func (r *mutationResolver) CreateParentComment(ctx context.Context, postID string, authorID string, content string) (*model.Comment, error) {
	// Проверяем ограничение в 2000 символов
	if len(content) > 2000 {
		return nil, fmt.Errorf("комментарий не может содержать более 2000 символов")
	}

	// Конвертируем postID и authorID в uint
	postIDUint, _ := strconv.ParseUint(postID, 10, 64)
	authorIDUint, _ := strconv.ParseUint(authorID, 10, 64)

	// Проверяем, существует ли пост
	var post models.Post
	if err := r.DB.First(&post, uint(postIDUint)).Error; err != nil {
		return nil, fmt.Errorf("пост не найден")
	}

	// Проверяем, разрешены ли комментарии
	if !post.AllowComments {
		return nil, fmt.Errorf("комментирование запрещено автором поста")
	}

	// Создаём родительский комментарий
	comment := &models.Comment{
		PostID:   uint(postIDUint),
		AuthorID: uint(authorIDUint),
		Content:  content,
		ParentID: nil, // Это родительский комментарий
	}

	// Сохраняем в БД
	if err := r.DB.Create(comment).Error; err != nil {
		return nil, fmt.Errorf("не удалось создать родительский комментарий: %w", err)
	}

	// Подготавливаем ответ
	resComment := &model.Comment{
		ID:        strconv.FormatUint(uint64(comment.ID), 10),
		PostID:    strconv.FormatUint(uint64(comment.PostID), 10),
		AuthorID:  strconv.FormatUint(uint64(comment.AuthorID), 10),
		Content:   comment.Content,
		CreatedAt: comment.CreatedAt.String(),
	}

	return resComment, nil
}

// CreateChildComment - создание вложенного комментария (с parentID)
func (r *mutationResolver) CreateChildComment(ctx context.Context, postID string, authorID string, content string, parentID string) (*model.Comment, error) {
	// Проверяем ограничение в 2000 символов
	if len(content) > 2000 {
		return nil, fmt.Errorf("комментарий не может содержать более 2000 символов")
	}

	// Конвертируем postID, authorID и parentID в uint
	postIDUint, _ := strconv.ParseUint(postID, 10, 64)
	authorIDUint, _ := strconv.ParseUint(authorID, 10, 64)
	parentIDUint, _ := strconv.ParseUint(parentID, 10, 64)

	// Проверяем, существует ли пост
	var post models.Post
	if err := r.DB.First(&post, uint(postIDUint)).Error; err != nil {
		return nil, fmt.Errorf("пост не найден")
	}

	// Проверяем, разрешены ли комментарии
	if !post.AllowComments {
		return nil, fmt.Errorf("комментирование запрещено автором поста")
	}

	// Проверяем, существует ли родительский комментарий
	var parentComment models.Comment
	if err := r.DB.First(&parentComment, uint(parentIDUint)).Error; err != nil {
		return nil, fmt.Errorf("родительский комментарий не найден")
	}

	// Создаём вложенный комментарий
	comment := &models.Comment{
		PostID:   uint(postIDUint),
		AuthorID: uint(authorIDUint),
		Content:  content,
		ParentID: &parentComment.ID, // Это вложенный комментарий
	}

	// Сохраняем в БД
	if err := r.DB.Create(comment).Error; err != nil {
		return nil, fmt.Errorf("не удалось создать вложенный комментарий: %w", err)
	}

	// Подготавливаем ответ
	resComment := &model.Comment{
		ID:        strconv.FormatUint(uint64(comment.ID), 10),
		PostID:    strconv.FormatUint(uint64(comment.PostID), 10),
		AuthorID:  strconv.FormatUint(uint64(comment.AuthorID), 10),
		Content:   comment.Content,
		CreatedAt: comment.CreatedAt.String(),
		ParentID:  &parentID, // Указываем родителя
	}

	return resComment, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, name string) (*model.User, error) {
	// Создаём нового пользователя
	user := &models.User{
		Name: name,
	}

	// Сохраняем пользователя в БД
	if err := r.DB.Create(user).Error; err != nil {
		log.Printf("Ошибка при создании пользователя: %v", err)
		return nil, fmt.Errorf("не удалось создать пользователя: %w", err)
	}

	// Конвертируем в GraphQL-модель
	resUser := model.User{
		ID:        strconv.FormatUint(uint64(user.ID), 10),
		Name:      user.Name,
		CreatedAt: user.CreatedAt.String(),
	}

	return &resUser, nil
}

// ToggleAllowComments запрещает или разрешает комментарии для поста
func (r *mutationResolver) ToggleAllowComments(ctx context.Context, postID string) (*model.Post, error) {
	postIDUint, err := strconv.ParseUint(postID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("неверный формат ID поста")
	}

	var post models.Post
	if err := r.DB.First(&post, uint(postIDUint)).Error; err != nil {
		return nil, fmt.Errorf("пост не найден")
	}

	// Меняем состояние разрешения комментариев
	post.AllowComments = !post.AllowComments

	if err := r.DB.Save(&post).Error; err != nil {
		return nil, fmt.Errorf("не удалось обновить статус комментариев: %w", err)
	}

	return &model.Post{
		ID:            strconv.FormatUint(uint64(post.ID), 10),
		Title:         post.Title,
		Content:       post.Content,
		AllowComments: post.AllowComments,
		CreatedAt:     post.CreatedAt.String(),
	}, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string, limit *int32, offset *int32) (*model.Post, error) {
	postIDUint, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("неверный формат ID поста")
	}

	// Ищем пост
	var post models.Post
	if err := r.DB.First(&post, uint(postIDUint)).Error; err != nil {
		return nil, fmt.Errorf("пост не найден")
	}

	// Преобразуем указатели *int32 в int, если они не nil
	lim := 10 // Значение по умолчанию
	off := 0  // Значение по умолчанию
	if limit != nil {
		lim = int(*limit)
	}
	if offset != nil {
		off = int(*offset)
	}

	// Загружаем комментарии с учетом пагинации
	var comments []models.Comment
	if err := r.DB.Where("post_id = ?", post.ID).
		Limit(lim).
		Offset(off).
		Order("created_at ASC").
		Find(&comments).Error; err != nil {
		return nil, fmt.Errorf("ошибка загрузки комментариев")
	}

	// Преобразуем комментарии в GraphQL-модель
	var gqlComments []*model.Comment
	for _, c := range comments {
		parentID := ""
		if c.ParentID != nil {
			parentID = strconv.FormatUint(uint64(*c.ParentID), 10)
		}
		gqlComments = append(gqlComments, &model.Comment{
			ID:        strconv.FormatUint(uint64(c.ID), 10),
			PostID:    strconv.FormatUint(uint64(c.PostID), 10),
			AuthorID:  strconv.FormatUint(uint64(c.AuthorID), 10),
			Content:   c.Content,
			CreatedAt: c.CreatedAt.String(),
			ParentID:  &parentID,
		})
	}

	// Возвращаем пост с комментариями
	return &model.Post{
		ID:            strconv.FormatUint(uint64(post.ID), 10),
		Title:         post.Title,
		Content:       post.Content,
		AllowComments: post.AllowComments,
		Comments:      gqlComments,
	}, nil
}

// Posts is the resolver for fetching all posts with pagination.
func (r *queryResolver) Posts(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	// Преобразуем указатели *int32 в int, если они не nil
	lim := 10 // Значение по умолчанию
	off := 0  // Значение по умолчанию
	if limit != nil {
		lim = int(*limit)
	}
	if offset != nil {
		off = int(*offset)
	}

	// Получаем список постов из базы данных
	var posts []models.Post
	if err := r.DB.Limit(lim).Offset(off).Order("created_at DESC").Find(&posts).Error; err != nil {
		return nil, fmt.Errorf("ошибка при получении постов: %w", err)
	}

	// Конвертируем в GraphQL-модель
	var result []*model.Post
	for _, post := range posts {
		result = append(result, &model.Post{
			ID:            strconv.FormatUint(uint64(post.ID), 10),
			Title:         post.Title,
			Content:       post.Content,
			AllowComments: post.AllowComments,
			CreatedAt:     post.CreatedAt.String(),
		})
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
